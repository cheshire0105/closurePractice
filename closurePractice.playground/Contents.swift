import UIKit

//: # 클로저의 이해
/*:
 클로저는 "이름이 없는 함수"라고 생각 하면 쉽습니다. \
 또한 클로저는 범위 안에서 생성된 변수나, 상수의 참조를 "캡쳐" 할 수 있습니다.
 */
//: ## 여기서 "캡쳐"란?
/*:
 스위프트에서 참조 타입은 크게 두가지 입니다. \
 클래스와 클로저가 그 두가지 타입입니다. \
 참조 타입은 값을 복사 하지 않고, 그 틀이 저장 되어 있는 메모리 공간의 주소를 "참조"해서 사용 합니다. \
 그렇기 때문에 틀에서 찍어낸 것들은 틀의 변화에 영향을 받습니다. \
 \
 "캡쳐"라는건 클로저가 주변의 변수나 상수를 저장 하고 참조 한다는 것을 말합니다. \
 때문에 클로저 범위 밖에서도 계속 그 값을 사용 할 수 있는 것입니다. \
 앞서 말한 것 처럼, 클래스나 클로저는 "참조" 타입입니다. \
 값을 heap이라는 메모리 공간에 저장 하기 때문인데요.
 */
//: ## 메모리 공간과 참조 타입.
/*:
 값을 heap에 저장 하는 것은 좀 더 장기적으로 저장하고 사용 하겠다는 이야기와 같습니다. \
 우선 단순한 함수는 stack영역에서 생성 되고 사라지는데요. 일회성이고 함수가 끝나면 메모리 공간에서 사라지며 함수가 종료 되게 됩니다. \
 그러나 heap은 다릅니다. ARC라는 스위프트에서 메모리를 자동으로 관리 해주는 기능을 사용하지만, \
 heap에 저장 되는 기억들은 조금 더 오래 남으며, 때로는 메모리에서 지워지지 않는 강렬한 기억으로 남는 경우도 있습니다.
 */
//: # 클로저의 예시
/*:
 클로저는 이름이 없는 함수라고 밝혔습니다. 때문에 함수 타입의 파라미터를 받는데요. \
 아래가 그 예입니다. 아래의 함수는 Int 라는 정수를 파라미터를 받고 "() -> Int"인 함수 타입을 반환 합니다. \
 그 함수 타입을 사용 하는 것이 아래의 예시의 상수 클로저 입니다. \
 아래 예시의 클로저는 "() -> Int"의 타입입니다. \
 \
 처음 함수를 넣고 계속 객체를 찍어내며 숫자를 증가 하게 만들었습니다. \
 처음엔 0으로 시작 되며 리턴형이 "() -> Int"의 함수 타입 임으로 incrementer를 리턴 하게 되어 있습니다. \
 여기서 생성한 객체를 계속 해서 다른 객체에 넣어도 그 전에 가지고 있는 숫자를 참조 하며 더하게 되는데요. \
 이렇게 클로저를 변수나 상수에 넣어서 계속 사용 하는 것을 "캡쳐"라고 하는 것입니다. \
 앞서 말했듯 변수가 heap에 저장 되어서 장기적으로 기억 되는 것입니다. \
 니체는 망각을 신의 축복이라고 말하며 그 중요성을 언급 했습니다. \
 heap에 오래 남는 것이 과연 좋을까요?
 */
func makeIncrementer(amount: Int) -> () -> Int {
    var total = 0
    let incrementer: () -> Int = {
        total += amount
        return total
    }
    return incrementer
}

let increment = makeIncrementer(amount: 4)
let firstIncrementer = increment
let secondIncrementer = firstIncrementer


print(increment())
print(firstIncrementer())
print(secondIncrementer())
//: # 클로저의 순환 참조
/*:
 당연하게도 메모리에 계속 남는건, 망각 되지 않는건 컴퓨터와 우리의 정신에 좋지 않습니다. \
 잊기 때문에 추억이 되고, 새로운 사람을 만날 수 있는 것입니다. \
 클로저를 사용해서 heap에 오래 남기는건 메모리 관리 측면에서 우리의 관심을 필요로 합니다. \
 우리가 수동으로 사라질 기억을 정해 주어야 하는 것이랑 비슷 합니다. \
 밑의 클래스는 클로저를 가지고 있습니다. closure 변수가 그것입니다. \
 그리고 메서드를 통해서 그 클로저에 계속 값을 더해줄 수 있는 기능을 넣었습니다. \
 또한 deinit을 통해서 메모리에서 해제 되면 print문을 찍어낼 수 있게 해주었습니다.
 \
 MyClass 타입의 인스턴스를 하나 만들었습니다. \
 인스턴스의 메서드를 실행 하여 기능을 실행해보았고, "instance = nil"를 통해서 직접적으로 값을 nil로 만들었습니다. \
 그러나 deinit이 출력 됐나요? 이 기억은 망각 되었나요?
 \
 사라지지 않았습니다. \
 그 이유는 아래의 예는 "순환 참조"가 되었기 때문입니다. \
 우리는 아래의 함수에서 클로저가 클래스의 인스턴스를 "캡쳐"하게 했습니다. \
 이렇게 되면 클래스 내부의 클로저와 클래스 내부의 인스턴스가 서로가 서로를 필요 하게 되어 메모리에서 해제 되지 않는 문제가 발생 합니다. \
 \
 이런 문제를 "순환 참조"라고 하는 것입니다. \
 그럼 이 문제를 어떻게 해결 할까요?
 */
class MyClass {
    var value = 0
    var closure: (() -> Void)?

    func setupClosure() {
        closure = {
            self.value += 1
        }
    }
    
    deinit {
        print("기억에에서 추억이 되었습니다.")
    }
}

var instance: MyClass? = MyClass()
instance?.setupClosure()
instance = nil
//: # 순환 참조 문제의 해결법
/*:
 기억을 수동으로 관리 해야 한다면 어떤 해결 방법을 쓸 수 있을까요? \
 누군가와 이별 한다면 일상속의 물건들이라도 그와 연관 되어 있으면 쉽게 머릿 속에서 잊혀지지 않는 경우가 있습니다. \
 물건과 그를 연관 해서 기억 하기 때문입니다. \
 보통 인간의 뇌는 시간이 지나면서 그 연관성이 약해지거나, 망각으로 사라지거나 하면서 견뎌 냅니다. \
 \
 컴퓨터의 경우도 비슷하게 망각을 구현합니다. \
 우리에게 "시간"이 그 도구라면 스위프트에선 "Week"이라는 키워드를 통해서 그 연관성을 약하게 합니다.
 \
 아래의 예재를 실행해보겠습니다. \
 어떤가요? 추억이 됐나요?
 */
class MyClassWeek {
    var value = 0
    var closure: (() -> Void)?

    func setupClosure() {
        closure = { [weak self] in
            self?.value += 1
        }
    }
    
    deinit {
        print("기억에서 추억이 되었습니다.")
    }
}

var instanceWeek: MyClassWeek? = MyClassWeek()
instanceWeek?.setupClosure()
instanceWeek = nil
